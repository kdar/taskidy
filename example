#!/usr/bin/env bash

cd "$( dirname "${BASH_SOURCE[0]}" )" || exit
source ./taskidy.sh

# Says hello to you
# Some long
# description
#
# Usage:
#   ./taskfile hello [args...]
task:hello() {
  echo "Hello" "$@" "!"
}

# Prints the statement before executing
# This uses set -x to print the statement before
# running it. This particular example shows how
# to use a subshell so you don't actually print
# out "set -x".
task:print-before-exe() {
  (set -x; echo "YAY!" "$@")
}

# Exits the task on failure
# Uses set -e to exit the task when a command fails.
task:exit-on-fail() {
  set -e
  echo "Before"
  cat /tmp/sdfdsfdfgfghfghs
  echo "After"
}

# Exits the task on failure, except when skipped
# Uses set -e to exit the task when a command fails,
# but shows how you can ignore the return value of
# a command in case you don't care if it fails.
task:exit-on-fail-skip() {
  set -e
  echo "Before"
  cat /tmp/sdfdsfdfgfghfghs || true
  echo "After"
}

# Recompiles if source has changed
# This task will recompile a C program if the source
# files have changed.
task:depend-on() {
  # shellcheck disable=SC2034
  local -a inputs=(testdata/depend/src/*.{c,h})
  # shellcheck disable=SC2034
  local -a outputs=(testdata/depend/dist/main)
  if taskidy.timestamp_depend inputs outputs; then
    echo "Recompiling..."
    gcc -o testdata/depend/dist/main testdata/depend/src/main.c
    echo "Done"
  fi
}

parallel1() {
  sleep 2
  echo "parallel1: done"
}

parallel2() {
  sleep 3
  echo "parallel2: done"
  # return 1
}

task:parallel() {
  if taskidy.parallel parallel1 parallel2; then
    echo "All exited successfully"
  else
    echo "There was an error!"
  fi
}

# The default task
# The task that is executed if no task is
# provided on the CLI.
task:default() {
  echo "default" "$@"
}
